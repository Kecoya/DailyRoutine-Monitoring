# 监控间隔优化说明

## 📊 改进内容

### 原配置
```python
MONITOR_INTERVAL = 60  # 每60秒保存一次数据
```

### 新配置
```python
MONITOR_INTERVAL = 5  # 每5秒保存一次数据
```

## 🔍 重要澄清

### 鼠标距离测量精度

很多人可能会误解"60秒间隔"的含义。实际上：

#### ✅ 鼠标监听是实时的
```python
def on_mouse_move(self, x, y):
    """鼠标移动事件 - 每次移动都会触发"""
    if self.last_mouse_pos:
        distance = ((x - self.last_mouse_pos[0]) ** 2 + 
                   (y - self.last_mouse_pos[1]) ** 2) ** 0.5
        self.mouse_distance += distance  # 实时累加
    self.last_mouse_pos = (x, y)
```

**关键点：**
- 🎯 鼠标**每次移动**都会触发 `on_mouse_move` 函数
- 🎯 距离在**每次移动时**都会实时累加到 `self.mouse_distance`
- 🎯 不存在采样间隔问题
- 🎯 鼠标移动距离的测量是**完全精确**的

#### ⏱️ 间隔只影响数据保存
```python
# 每隔 MONITOR_INTERVAL 秒
# 1. 将累积的数据保存到数据库
# 2. 重置计数器
# 3. 开始下一个周期的累积
```

**MONITOR_INTERVAL 的作用：**
- 决定数据保存到数据库的频率
- 决定活动记录的时间粒度
- 影响忙碌曲线图的数据点密度

## 📈 改为5秒间隔的好处

### 1. 更细的时间粒度
```
原来：60秒一个数据点  → 1小时60个点  → 1天1440个点
现在：5秒一个数据点   → 1小时720个点  → 1天17280个点
```

### 2. 更准确的忙碌曲线
- 可以看到**5秒级别**的活动变化
- 短时间的高强度工作不会被平滑掉
- 空闲时间识别更准确

### 3. 更精确的时间统计
```
原来：活动时间只能精确到分钟
现在：活动时间可以精确到5秒
```

### 4. 示例对比

**场景：** 你在9:00-9:05工作，9:05-9:10休息

**原方案（60秒）：**
```
9:00 - 9:01: [记录] 60秒的数据
9:01 - 9:02: [记录] 60秒的数据
...
结果：可能显示9:00-9:10都在工作（取决于采样时机）
```

**新方案（5秒）：**
```
9:00 - 9:00:05: [记录] 5秒的数据
9:00:05 - 9:00:10: [记录] 5秒的数据
...
9:05 - 9:05:05: [记录] 5秒的数据（开始休息）
...
结果：准确显示9:05开始休息
```

## ⚡ 性能影响

### 数据量变化
```
原来：1天 = 1440条记录
现在：1天 = 17280条记录（12倍）
```

### 存储影响
```
每条记录约 200 字节
1天数据：
  原来：1440 × 200B ≈ 280 KB
  现在：17280 × 200B ≈ 3.4 MB

1年数据：
  原来：280KB × 365 ≈ 100 MB
  现在：3.4MB × 365 ≈ 1.2 GB
```

**结论：** 对于现代计算机，1.2GB的年度数据量完全可以接受。

### CPU影响
```
数据库写入频率：
  原来：每60秒写入1次
  现在：每5秒写入1次（增加12倍）

实际影响：
  - SQLite写入速度：>10000条/秒
  - 我们的写入速度：0.2条/秒
  - CPU占用率增加：<0.01%
```

**结论：** CPU影响可以忽略不计。

## 🔧 如何进一步调整

如果你想要不同的间隔，可以修改 `config.py`：

### 超高精度（每秒保存）
```python
MONITOR_INTERVAL = 1  # 1秒间隔
```
- ✅ 最高时间精度
- ⚠️ 数据量最大（1年约6GB）
- 适合：需要精确分析短时间活动模式

### 当前推荐（每5秒）
```python
MONITOR_INTERVAL = 5  # 5秒间隔（默认）
```
- ✅ 精度与性能平衡最佳
- ✅ 数据量适中（1年约1.2GB）
- 适合：大多数使用场景

### 较低精度（每30秒）
```python
MONITOR_INTERVAL = 30  # 30秒间隔
```
- ✅ 数据量较小（1年约200MB）
- ⚠️ 精度降低
- 适合：长期存储，关注大趋势

### 原配置（每60秒）
```python
MONITOR_INTERVAL = 60  # 60秒间隔
```
- ✅ 数据量最小（1年约100MB）
- ⚠️ 精度最低
- 适合：低配置设备或极长期存储

## 📝 活动指标自动适配

代码已经自动适配不同的间隔：

```python
# 自动计算系数
interval_factor = MONITOR_INTERVAL / 60

# 期望值自动调整
mouse_activity_score = min(100, 
    self.mouse_clicks / (50 * interval_factor) * 100
)
```

**这意味着：**
- 无论设置什么间隔，忙碌指数的计算都是准确的
- 不需要手动调整其他参数

## ⚙️ 生效方式

修改 `config.py` 后：

1. **新启动的监控服务**：立即生效
2. **正在运行的服务**：需要重启才能生效

### 重启方法
```bash
# 方法1：使用批处理文件
启动监控.bat

# 方法2：手动重启
# 1. 关闭正在运行的监控程序
# 2. 重新运行 python main.py
```

## 🎯 总结

### 改进效果
| 项目 | 原配置(60s) | 新配置(5s) | 提升 |
|-----|-----------|-----------|------|
| 时间精度 | 分钟级 | 5秒级 | 12倍 |
| 数据点数 | 1440/天 | 17280/天 | 12倍 |
| 忙碌曲线精度 | 低 | 高 | 显著提升 |
| 年度数据量 | 100MB | 1.2GB | 12倍 |
| CPU影响 | 极低 | 极低 | 无感 |

### 建议
✅ **推荐使用5秒间隔**（当前默认配置）
- 在精度和性能之间达到最佳平衡
- 适合日常使用和长期数据分析

### 注意事项
⚠️ **鼠标距离测量精度与此无关**
- 鼠标距离始终是实时精确测量的
- 改变间隔只影响数据保存的时间粒度
- 不会让鼠标距离"更准确"（已经是最准确的了）

---

**配置文件：** `config.py` 第25行
```python
MONITOR_INTERVAL = 5  # 调整此值以改变数据保存间隔
```

